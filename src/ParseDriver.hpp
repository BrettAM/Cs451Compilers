#ifndef PARSEDRIVER_H
#define PARSEDRIVER_H

#include <vector>
#include <algorithm>
#include <stdio.h>
#include <iostream>
#include <map>
#include "Token.hpp"
#include "AST.hpp"
#include "Error.hpp"

namespace ParseDriver {
    class Result {
    private:
        std::vector<const Token*>* tokens;
        AST::Node* AST;
        Error* error;
    public:
        Result(std::vector<const Token*>* tokens, AST::Node* AST, Error* error):
            tokens(tokens), AST(AST), error(error) {}
        const std::vector<const Token*>* getTokens() const { return tokens; }
        AST::Node* getAST() const { return AST; }
        bool getErrorFlag() const { return error != NULL; }
        Error* getError() const { return error; }
        /**
         * Free all the memory associated with the result. All references
         * to the original tokens and AST become invalid.
         */
        void cleanup();
    };

    ///////// function below for use by flex/bison //////////
    /**
     * Interface to log an error from flex/bison
     */
    void pushError(const char *);
    /**
     * Interface for flex to add a token pointer to the results
     */
    int pushToken(const Token* t);
    /**
     * Interface for bison to return the final AST
     */
    void rootAST(AST::Node * AST);
    /**
     * Add a record to the global id namespace
     */
    void pushGlobal(const Token* record);
    /**
     * Returns true if an id name matches a previously defined record
     */
    bool isRecord(cstr idname);

    ///////// functions below for use by the compiler ///////////
    /**
     * Run a flex/bison pass over an input string
     */
    Result run(const char* str);
    /**
     * Run a flex/bison pass over the contents of a file
     */
    Result run(FILE* f);
    /**
     * Enable debugging details in flex and bison
     */
     void enableDebug();
}

#endif
